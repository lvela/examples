/* Generated by Opal 0.7.0.dev */
Opal.modules["math"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $module = $opal.module, $klass = $opal.klass;

  $opal.add_stubs(['$===', '$raise', '$type_error', '$to_f', '$log', '$include']);
  return (function($base) {
    var self = $module($base, 'Math');

    var def = self._proto, $scope = self._scope, $a;

    (function($base, $super) {
      function $DomainError(){};
      var self = $DomainError = $klass($base, $super, 'DomainError', $DomainError);

      var def = self._proto, $scope = self._scope, TMP_1;

      return ($opal.defs(self, '$new', TMP_1 = function(method) {
        var self = this, $iter = TMP_1._p, $yield = $iter || nil;

        TMP_1._p = null;
        return $opal.find_super_dispatcher(self, 'new', TMP_1, null, $DomainError).apply(self, ["Numerical argument is out of domain - \"" + (method) + "\""]);
      }), nil) && 'new'
    })(self, $scope.get('StandardError'));

    $opal.cdecl($scope, 'E', Math.E);

    $opal.cdecl($scope, 'PI', Math.PI);

    def.$acos = function(x) {
      var self = this;

      
      if (!$scope.get('Numeric')['$==='](x)) {
        self.$raise($scope.get('Opal').$type_error(x, $scope.get('Float')));
      }

      x = x.$to_f();

      if (x < -1 || x > 1) {
        self.$raise($scope.get('DomainError'), "acos");
      }

      return Math.acos(x);
    ;
    };

    if ((($a = (typeof(Math.acosh) !== "undefined")) !== nil && (!$a._isBoolean || $a == true))) {
      } else {
      
      Math.acosh = function(x) {
        return Math.log(x + Math.sqrt(x * x - 1));
      }
    
    };

    def.$acosh = function(x) {
      var self = this;

      
      if (!$scope.get('Numeric')['$==='](x)) {
        self.$raise($scope.get('Opal').$type_error(x, $scope.get('Float')));
      }

      return Math.acosh(x.$to_f());
    ;
    };

    def.$asin = function(x) {
      var self = this;

      
      if (!$scope.get('Numeric')['$==='](x)) {
        self.$raise($scope.get('Opal').$type_error(x, $scope.get('Float')));
      }

      x = x.$to_f();

      if (x < -1 || x > 1) {
        self.$raise($scope.get('DomainError'), "asin");
      }

      return Math.asin(x);
    ;
    };

    if ((($a = (typeof(Math.asinh) !== "undefined")) !== nil && (!$a._isBoolean || $a == true))) {
      } else {
      
      Math.asinh = function(x) {
        return Math.log(x + Math.sqrt(x * x + 1))
      }
    ;
    };

    def.$asinh = function(x) {
      var self = this;

      
      if (!$scope.get('Numeric')['$==='](x)) {
        self.$raise($scope.get('Opal').$type_error(x, $scope.get('Float')));
      }

      return Math.asinh(x.$to_f());
    ;
    };

    def.$atan = function(x) {
      var self = this;

      
      if (!$scope.get('Numeric')['$==='](x)) {
        self.$raise($scope.get('Opal').$type_error(x, $scope.get('Float')));
      }

      return Math.atan(x.$to_f());
    ;
    };

    def.$atan2 = function(x, y) {
      var self = this;

      
      if (!$scope.get('Numeric')['$==='](x)) {
        self.$raise($scope.get('Opal').$type_error(x, $scope.get('Float')));
      }

      if (!$scope.get('Numeric')['$==='](y)) {
        self.$raise($scope.get('Opal').$type_error(y, $scope.get('Float')));
      }

      return Math.atan2(x.$to_f(), y.$to_f());
    ;
    };

    if ((($a = (typeof(Math.atanh) !== "undefined")) !== nil && (!$a._isBoolean || $a == true))) {
      } else {
      
      Math.atanh = function(x) {
        return 0.5 * Math.log((1 + x) / (1 - x));
      }
    
    };

    def.$atanh = function(x) {
      var self = this;

      
      if (!$scope.get('Numeric')['$==='](x)) {
        self.$raise($scope.get('Opal').$type_error(x, $scope.get('Float')));
      }

      x = x.$to_f();

      if (x < -1 || x > 1) {
        self.$raise($scope.get('DomainError'), "atanh");
      }

      return Math.atanh(x);
    ;
    };

    def.$cbrt = function(x) {
      var self = this;

      return Math.cbrt(x);
    };

    def.$cos = function(x) {
      var self = this;

      
      if (!$scope.get('Numeric')['$==='](x)) {
        self.$raise($scope.get('Opal').$type_error(x, $scope.get('Float')));
      }

      return Math.cos(x.$to_f());
    ;
    };

    if ((($a = (typeof(Math.cosh) !== "undefined")) !== nil && (!$a._isBoolean || $a == true))) {
      } else {
      
      Math.cosh = function(x) {
        return (Math.exp(x) + Math.exp(-x)) / 2;
      }
    
    };

    def.$cosh = function(x) {
      var self = this;

      
      if (!$scope.get('Numeric')['$==='](x)) {
        self.$raise($scope.get('Opal').$type_error(x, $scope.get('Float')));
      }

      return Math.cosh(x.$to_f());
    ;
    };

    def.$erf = function(x) {
      var self = this;

      return self.$raise($scope.get('NotImplementedError'));
    };

    def.$erfc = function(x) {
      var self = this;

      return self.$raise($scope.get('NotImplementedError'));
    };

    def.$exp = function(x) {
      var self = this;

      
      if (!$scope.get('Numeric')['$==='](x)) {
        self.$raise($scope.get('Opal').$type_error(x, $scope.get('Float')));
      }

      return Math.exp(x.$to_f());
    ;
    };

    def.$frexp = function(x) {
      var self = this;

      return self.$raise($scope.get('NotImplementedError'));
    };

    def.$gamma = function(x) {
      var self = this;

      return self.$raise($scope.get('NotImplementedError'));
    };

    if ((($a = (typeof(Math.hypot) !== "undefined")) !== nil && (!$a._isBoolean || $a == true))) {
      } else {
      
      Math.hypot = function(x, y) {
        return Math.sqrt(x * x + y * y)
      }
    ;
    };

    def.$hypot = function(x, y) {
      var self = this;

      
      if (!$scope.get('Numeric')['$==='](x)) {
        self.$raise($scope.get('Opal').$type_error(x, $scope.get('Float')));
      }

      if (!$scope.get('Numeric')['$==='](y)) {
        self.$raise($scope.get('Opal').$type_error(y, $scope.get('Float')));
      }

      return Math.hypot(x.$to_f(), y.$to_f());
    ;
    };

    def.$ldexp = function(flt, int$) {
      var self = this;

      return self.$raise($scope.get('NotImplementedError'));
    };

    def.$lgamma = function(x) {
      var self = this;

      return self.$raise($scope.get('NotImplementedError'));
    };

    def.$log = function(num, base, method) {
      var $a, self = this;

      if (base == null) {
        base = $scope.get('E')
      }
      if (method == null) {
        method = nil
      }
      
      if (!$scope.get('Numeric')['$==='](num)) {
        self.$raise($scope.get('Opal').$type_error(num, $scope.get('Float')));
      }

      if (!$scope.get('Numeric')['$==='](base)) {
        self.$raise($scope.get('Opal').$type_error(base, $scope.get('Float')));
      }

      num  = num.$to_f();
      base = base.$to_f();

      if (num < 0) {
        self.$raise($scope.get('DomainError'), ((($a = method) !== false && $a !== nil) ? $a : "log"));
      }

      num = Math.log(num);

      if (base != Math.E) {
        num /= Math.log(base);
      }

      return num
    ;
    };

    if ((($a = (typeof(Math.log10) !== "undefined")) !== nil && (!$a._isBoolean || $a == true))) {
      def.$log10 = function(num) {
        var self = this;

        
        if (!$scope.get('Numeric')['$==='](num)) {
          self.$raise($scope.get('Opal').$type_error(num, $scope.get('Float')));
        }

        num = num.$to_f();

        if (num < 0) {
          self.$raise($scope.get('DomainError'), "log2");
        }

        return Math.log10(num);
      ;
      }
      } else {
      def.$log10 = function(num) {
        var self = this;

        return self.$log(num, 10, "log10");
      }
    };

    if ((($a = (typeof(Math.log2) !== "undefined")) !== nil && (!$a._isBoolean || $a == true))) {
      def.$log2 = function(num) {
        var self = this;

        
        if (!$scope.get('Numeric')['$==='](num)) {
          self.$raise($scope.get('Opal').$type_error(num, $scope.get('Float')));
        }

        num = num.$to_f();

        if (num < 0) {
          self.$raise($scope.get('DomainError'), "log2");
        }

        return Math.log2(num);
      ;
      }
      } else {
      def.$log2 = function(num) {
        var self = this;

        return self.$log(num, 2, "log2");
      }
    };

    def.$sin = function(x) {
      var self = this;

      
      if (!$scope.get('Numeric')['$==='](x)) {
        self.$raise($scope.get('Opal').$type_error(x, $scope.get('Float')));
      }

      return Math.sin(x.$to_f());
    ;
    };

    if ((($a = (typeof(Math.sinh) !== "undefined")) !== nil && (!$a._isBoolean || $a == true))) {
      } else {
      
      Math.sinh = function(x) {
        return (Math.exp(x) - Math.exp(-x)) / 2;
      }
    
    };

    def.$sinh = function(x) {
      var self = this;

      
      if (!$scope.get('Numeric')['$==='](x)) {
        self.$raise($scope.get('Opal').$type_error(x, $scope.get('Float')));
      }

      return Math.sinh(x.$to_f());
    ;
    };

    def.$sqrt = function(x) {
      var self = this;

      
      if (!$scope.get('Numeric')['$==='](x)) {
        self.$raise($scope.get('Opal').$type_error(x, $scope.get('Float')));
      }

      x = x.$to_f();

      if (x < 0) {
        self.$raise($scope.get('DomainError'), "log2");
      }

      return Math.sqrt(x);
    ;
    };

    def.$tan = function(x) {
      var self = this;

      
      if (!$scope.get('Numeric')['$==='](x)) {
        self.$raise($scope.get('Opal').$type_error(x, $scope.get('Float')));
      }

      return Math.tan(x.$to_f());
    ;
    };

    if ((($a = (typeof(Math.tanh) !== "undefined")) !== nil && (!$a._isBoolean || $a == true))) {
      } else {
      
      Math.tanh = function(x) {
        if (x == Infinity) {
          return 1;
        }
        else if (x == -Infinity) {
          return -1;
        }
        else {
          return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));
        }
      }
    
    };

    def.$tanh = function(x) {
      var self = this;

      
      if (!$scope.get('Numeric')['$==='](x)) {
        self.$raise($scope.get('Opal').$type_error(x, $scope.get('Float')));
      }

      return Math.tanh(x.$to_f());
    ;
    };

    (function(self) {
      var $scope = self._scope, def = self._proto;

      return self.$include($scope.get('Math'))
    })(self.$singleton_class());
        ;$opal.donate(self, ["$acos", "$acosh", "$asin", "$asinh", "$atan", "$atan2", "$atanh", "$cbrt", "$cos", "$cosh", "$erf", "$erfc", "$exp", "$frexp", "$gamma", "$hypot", "$ldexp", "$lgamma", "$log", "$log10", "$log10", "$log2", "$log2", "$sin", "$sinh", "$sqrt", "$tan", "$tanh"]);
  })(self)
};

/* Generated by Opal 0.7.0.dev */
Opal.modules["thing"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass, $hash2 = $opal.hash2;

  $opal.add_stubs(['$attr_accessor', '$fetch', '$[]']);
  return (function($base, $super) {
    function $Thing(){};
    var self = $Thing = $klass($base, $super, 'Thing', $Thing);

    var def = self._proto, $scope = self._scope;

    self.$attr_accessor("position");

    return (def.$initialize = function(args) {
      var self = this;

      if (args == null) {
        args = $hash2([], {})
      }
      return self.position = args.$fetch("position", $scope.get('V')['$[]'](0, 0));
    }, nil) && 'initialize';
  })(self, null)
};

/* Generated by Opal 0.7.0.dev */
Opal.modules["asteroid"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass, $hash2 = $opal.hash2;

  $opal.add_stubs(['$[]', '$fetch', '$-', '$rand', '$*', '$move', '$wrap', '$+', '$>', '$-@', '$x', '$radius', '$x=', '$width', '$display', '$y', '$y=', '$height', '$<', '$distance_to', '$reject!', '$==', '$things', '$<<', '$new', '$stroke_color=', '$draw_polygon', '$private', '$/', '$push', '$translate', '$rotate', '$begin_shape', '$move_to', '$times', '$line_to', '$cos', '$sin', '$end_shape', '$stroke_shape', '$pop']);
  return (function($base, $super) {
    function $Asteroid(){};
    var self = $Asteroid = $klass($base, $super, 'Asteroid', $Asteroid);

    var def = self._proto, $scope = self._scope, TMP_1;

    def.position = def.velocity = def.rotation = def.rotation_speed = def.side_count = nil;
    $opal.cdecl($scope, 'COLOR', $scope.get('C')['$[]']("#ffffff"));

    $opal.cdecl($scope, 'RADIUS_PER_SIDE', 8);

    def.$initialize = TMP_1 = function(args) {var $zuper = $slice.call(arguments, 0);
      var self = this, $iter = TMP_1._p, $yield = $iter || nil;

      TMP_1._p = null;
      $opal.find_super_dispatcher(self, 'initialize', TMP_1, $iter).apply(self, $zuper);
      self.side_count = args.$fetch("side_count");
      self.rotation = 0;
      self.rotation_speed = $scope.get('Math').$rand()['$-'](0.5);
      return self.velocity = $scope.get('V')['$[]']($scope.get('Math').$rand()['$*'](50)['$-'](25), $scope.get('Math').$rand()['$*'](50)['$-'](25));
    };

    def.$update = function(elapsed, game) {
      var self = this;

      self.$move(elapsed);
      return self.$wrap(game);
    };

    def.$move = function(elapsed) {
      var self = this;

      self.position = self.position['$+'](self.velocity['$*'](elapsed));
      return self.rotation = self.rotation['$+'](self.rotation_speed['$*'](elapsed));
    };

    def.$wrap = function(game) {
      var $a, $b, self = this, left_overlap = nil, right_overlap = nil, top_overlap = nil, bottom_overlap = nil;

      if (((left_overlap = self.position.$x()['$-@']()['$-'](self.$radius())))['$>'](0)) {
        (($a = [game.$display().$width()['$-'](left_overlap)['$+'](self.$radius())]), $b = self.position, $b['$x='].apply($b, $a), $a[$a.length-1])
      } else if (((right_overlap = self.position.$x()['$-'](self.$radius())['$-'](game.$display().$width())))['$>'](0)) {
        (($a = [right_overlap['$-'](self.$radius())]), $b = self.position, $b['$x='].apply($b, $a), $a[$a.length-1])};
      if (((top_overlap = self.position.$y()['$-@']()['$-'](self.$radius())))['$>'](0)) {
        return (($a = [game.$display().$height()['$-'](top_overlap)['$+'](self.$radius())]), $b = self.position, $b['$y='].apply($b, $a), $a[$a.length-1])
      } else if (((bottom_overlap = self.position.$y()['$-'](self.$radius())['$-'](game.$display().$height())))['$>'](0)) {
        return (($a = [bottom_overlap['$-'](self.$radius())]), $b = self.position, $b['$y='].apply($b, $a), $a[$a.length-1])
        } else {
        return nil
      };
    };

    def['$colliding?'] = function(point) {
      var self = this;

      return self.position.$distance_to(point)['$<'](self.$radius());
    };

    def.$die = function(game) {
      var $a, $b, TMP_2, self = this;

      ($a = ($b = game.$things())['$reject!'], $a._p = (TMP_2 = function(t){var self = TMP_2._s || this;
if (t == null) t = nil;
      return t['$=='](self)}, TMP_2._s = self, TMP_2), $a).call($b);
      if (self.side_count['$>'](3)) {
        game.$things()['$<<']($scope.get('Asteroid').$new($hash2(["position", "side_count", "velocity"], {"position": self.position, "side_count": self.side_count['$-'](1), "velocity": $scope.get('V')['$[]'](self.velocity.$y()['$-@'](), self.velocity.$x())['$*'](2)})));
        return game.$things()['$<<']($scope.get('Asteroid').$new($hash2(["position", "side_count", "velocity"], {"position": self.position, "side_count": self.side_count['$-'](1), "velocity": $scope.get('V')['$[]'](self.velocity.$y(), self.velocity.$x()['$-@']())['$*'](2)})));
        } else {
        return nil
      };
    };

    def.$draw = function(display) {
      var $a, $b, self = this;

      (($a = [$scope.get('COLOR')]), $b = display, $b['$stroke_color='].apply($b, $a), $a[$a.length-1]);
      return self.$draw_polygon(display, self.position, self.rotation, self.side_count, self.$radius());
    };

    self.$private();

    def.$radius = function() {
      var self = this;

      return self.side_count['$*']($scope.get('RADIUS_PER_SIDE'));
    };

    return (def.$draw_polygon = function(d, position, rotation, side_count, radius) {
      var $a, $b, TMP_3, self = this, angle_per = nil;

      angle_per = (($scope.get('Math'))._scope.get('PI'))['$*'](2)['$/'](side_count);
      d.$push();
      d.$translate(self.position);
      d.$rotate(self.rotation);
      d.$begin_shape();
      d.$move_to($scope.get('V')['$[]'](radius, 0));
      ($a = ($b = side_count).$times, $a._p = (TMP_3 = function(i){var self = TMP_3._s || this;
if (i == null) i = nil;
      return d.$line_to($scope.get('V')['$[]'](radius['$*']($scope.get('Math').$cos(angle_per['$*'](i))), radius['$*']($scope.get('Math').$sin(angle_per['$*'](i)))))}, TMP_3._s = self, TMP_3), $a).call($b);
      d.$end_shape();
      d.$stroke_shape();
      return d.$pop();
    }, nil) && 'draw_polygon';
  })(self, $scope.get('Thing'))
};

/* Generated by Opal 0.7.0.dev */
Opal.modules["bullet"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass;

  $opal.add_stubs(['$fetch', '$[]', '$move', '$wrap', '$collide', '$self_destruct', '$along!', '$*', '$/', '$>', '$-', '$-@', '$x', '$x=', '$+', '$width', '$display', '$y', '$y=', '$height', '$each', '$respond_to?', '$colliding?', '$die', '$reject!', '$==', '$things', '$stroke_color=', '$push', '$translate', '$rotate', '$stroke_rectangle', '$pop']);
  return (function($base, $super) {
    function $Bullet(){};
    var self = $Bullet = $klass($base, $super, 'Bullet', $Bullet);

    var def = self._proto, $scope = self._scope, TMP_1;

    def.position = def.direction = def.size = def.age = nil;
    $opal.cdecl($scope, 'SPIN_SPEED', 0.6);

    $opal.cdecl($scope, 'MAX_AGE', 0.5);

    $opal.cdecl($scope, 'SPEED', 600);

    def.$initialize = TMP_1 = function(args) {var $zuper = $slice.call(arguments, 0);
      var self = this, $iter = TMP_1._p, $yield = $iter || nil;

      TMP_1._p = null;
      $opal.find_super_dispatcher(self, 'initialize', TMP_1, $iter).apply(self, $zuper);
      self.direction = args.$fetch("direction");
      self.size = $scope.get('V')['$[]'](8, 8);
      return self.age = 0;
    };

    def.$update = function(elapsed, game) {
      var self = this;

      self.$move(elapsed);
      self.$wrap(game);
      self.$collide(game);
      return self.$self_destruct(elapsed, game);
    };

    def.$move = function(elapsed) {
      var self = this;

      return self.position['$along!'](self.direction, $scope.get('SPEED')['$*'](elapsed));
    };

    def.$wrap = function(game) {
      var $a, $b, self = this, half_size = nil, left_overlap = nil, right_overlap = nil, top_overlap = nil, bottom_overlap = nil;

      half_size = self.size['$/'](2);
      if (((left_overlap = self.position.$x()['$-@']()['$-'](half_size.$x())))['$>'](0)) {
        (($a = [game.$display().$width()['$-'](left_overlap)['$+'](half_size.$y())]), $b = self.position, $b['$x='].apply($b, $a), $a[$a.length-1])
      } else if (((right_overlap = self.position.$x()['$-'](half_size.$x())['$-'](game.$display().$width())))['$>'](0)) {
        (($a = [right_overlap['$-'](half_size.$y())]), $b = self.position, $b['$x='].apply($b, $a), $a[$a.length-1])};
      if (((top_overlap = self.position.$y()['$-@']()['$-'](half_size.$y())))['$>'](0)) {
        return (($a = [game.$display().$height()['$-'](top_overlap)['$+'](half_size.$y())]), $b = self.position, $b['$y='].apply($b, $a), $a[$a.length-1])
      } else if (((bottom_overlap = self.position.$y()['$-'](half_size.$y())['$-'](game.$display().$height())))['$>'](0)) {
        return (($a = [bottom_overlap['$-'](half_size.$y())]), $b = self.position, $b['$y='].apply($b, $a), $a[$a.length-1])
        } else {
        return nil
      };
    };

    def.$collide = function(game) {try {

      var $a, $b, TMP_2, self = this;

      return ($a = ($b = game.$things()).$each, $a._p = (TMP_2 = function(thing){var self = TMP_2._s || this, $a, $b, TMP_3;
        if (self.position == null) self.position = nil;
if (thing == null) thing = nil;
      if ((($a = ($b = thing['$respond_to?']("colliding?"), $b !== false && $b !== nil ?thing['$colliding?'](self.position) : $b)) !== nil && (!$a._isBoolean || $a == true))) {
          thing.$die(game);
          ($a = ($b = game.$things())['$reject!'], $a._p = (TMP_3 = function(t){var self = TMP_3._s || this;
if (t == null) t = nil;
          return t['$=='](self)}, TMP_3._s = self, TMP_3), $a).call($b);
          $opal.$return(nil);
          } else {
          return nil
        }}, TMP_2._s = self, TMP_2), $a).call($b);
      } catch ($returner) { if ($returner === $opal.returner) { return $returner.$v } throw $returner; }
    };

    def.$self_destruct = function(elapsed, game) {
      var $a, $b, TMP_4, self = this;

      self.age = self.age['$+'](elapsed);
      if (self.age['$>']($scope.get('MAX_AGE'))) {
        return ($a = ($b = game.$things())['$reject!'], $a._p = (TMP_4 = function(t){var self = TMP_4._s || this;
if (t == null) t = nil;
        return t['$=='](self)}, TMP_4._s = self, TMP_4), $a).call($b)
        } else {
        return nil
      };
    };

    return (def.$draw = function(d) {
      var $a, $b, self = this;

      (($a = [(($scope.get('Ship'))._scope.get('COLOR'))]), $b = d, $b['$stroke_color='].apply($b, $a), $a[$a.length-1]);
      d.$push();
      d.$translate(self.position);
      d.$rotate((0.785)['$+'](self.direction));
      d.$stroke_rectangle(self.size['$/'](-2), self.size);
      return d.$pop();
    }, nil) && 'draw';
  })(self, $scope.get('Thing'))
};

/* Generated by Opal 0.7.0.dev */
Opal.modules["ship"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass, $hash2 = $opal.hash2;

  $opal.add_stubs(['$[]', '$*', '$control', '$move', '$wrap', '$collide', '$input', '$+', '$-', '$<<', '$things', '$new', '$along!', '$/', '$>', '$-@', '$x', '$x=', '$width', '$display', '$y', '$y=', '$height', '$each', '$respond_to?', '$colliding?', '$die', '$initialize', '$stroke_color=', '$push', '$translate', '$rotate', '$begin_shape', '$move_to', '$line_to', '$end_shape', '$stroke_shape', '$pop']);
  return (function($base, $super) {
    function $Ship(){};
    var self = $Ship = $klass($base, $super, 'Ship', $Ship);

    var def = self._proto, $scope = self._scope, TMP_1;

    def.direction = def.position = def.thrusting = def.velocity = def.size = nil;
    $opal.cdecl($scope, 'COLOR', $scope.get('C')['$[]']("#ffff88"));

    $opal.cdecl($scope, 'SPEED', 5);

    $opal.cdecl($scope, 'ROTATE_SPEED', 5);

    def.$initialize = TMP_1 = function(args) {var $zuper = $slice.call(arguments, 0);
      var self = this, $iter = TMP_1._p, $yield = $iter || nil;

      TMP_1._p = null;
      $opal.find_super_dispatcher(self, 'initialize', TMP_1, $iter).apply(self, $zuper);
      self.size = $scope.get('V')['$[]'](32, 32);
      self.velocity = $scope.get('V')['$[]'](0, 0);
      self.direction = (($scope.get('Math'))._scope.get('PI'))['$*'](1.5);
      return self.args = args;
    };

    def.$update = function(elapsed, game) {
      var self = this;

      self.$control(elapsed, game);
      self.$move(elapsed, game);
      self.$wrap(game);
      return self.$collide(game);
    };

    def.$control = function(elapsed, game) {
      var $a, self = this;

      if ((($a = game.$input()['$[]']("right")) !== nil && (!$a._isBoolean || $a == true))) {
        self.direction = self.direction['$+']($scope.get('ROTATE_SPEED')['$*'](elapsed))};
      if ((($a = game.$input()['$[]']("left")) !== nil && (!$a._isBoolean || $a == true))) {
        self.direction = self.direction['$-']($scope.get('ROTATE_SPEED')['$*'](elapsed))};
      self.thrusting = game.$input()['$[]']("up");
      if ((($a = game.$input()['$[]']("shoot")) !== nil && (!$a._isBoolean || $a == true))) {
        return game.$things()['$<<']($scope.get('Bullet').$new($hash2(["position", "direction"], {"position": self.position, "direction": self.direction})))
        } else {
        return nil
      };
    };

    def.$move = function(elapsed, game) {
      var $a, self = this;

      if ((($a = self.thrusting) !== nil && (!$a._isBoolean || $a == true))) {
        self.velocity['$along!'](self.direction, $scope.get('SPEED')['$*'](elapsed))};
      return self.position = self.position['$+'](self.velocity);
    };

    def.$wrap = function(game) {
      var $a, $b, self = this, half_size = nil, left_overlap = nil, right_overlap = nil, top_overlap = nil, bottom_overlap = nil;

      half_size = self.size['$/'](2);
      if (((left_overlap = self.position.$x()['$-@']()['$-'](half_size.$x())))['$>'](0)) {
        (($a = [game.$display().$width()['$-'](left_overlap)['$+'](half_size.$y())]), $b = self.position, $b['$x='].apply($b, $a), $a[$a.length-1])
      } else if (((right_overlap = self.position.$x()['$-'](half_size.$x())['$-'](game.$display().$width())))['$>'](0)) {
        (($a = [right_overlap['$-'](half_size.$y())]), $b = self.position, $b['$x='].apply($b, $a), $a[$a.length-1])};
      if (((top_overlap = self.position.$y()['$-@']()['$-'](half_size.$y())))['$>'](0)) {
        return (($a = [game.$display().$height()['$-'](top_overlap)['$+'](half_size.$y())]), $b = self.position, $b['$y='].apply($b, $a), $a[$a.length-1])
      } else if (((bottom_overlap = self.position.$y()['$-'](half_size.$y())['$-'](game.$display().$height())))['$>'](0)) {
        return (($a = [bottom_overlap['$-'](half_size.$y())]), $b = self.position, $b['$y='].apply($b, $a), $a[$a.length-1])
        } else {
        return nil
      };
    };

    def.$collide = function(game) {try {

      var $a, $b, TMP_2, self = this;

      return ($a = ($b = game.$things()).$each, $a._p = (TMP_2 = function(thing){var self = TMP_2._s || this, $a, $b;
        if (self.position == null) self.position = nil;
        if (self.args == null) self.args = nil;
if (thing == null) thing = nil;
      if ((($a = ($b = thing['$respond_to?']("colliding?"), $b !== false && $b !== nil ?thing['$colliding?'](self.position) : $b)) !== nil && (!$a._isBoolean || $a == true))) {
          thing.$die(game);
          self.$initialize(self.args);
          $opal.$return(nil);
          } else {
          return nil
        }}, TMP_2._s = self, TMP_2), $a).call($b);
      } catch ($returner) { if ($returner === $opal.returner) { return $returner.$v } throw $returner; }
    };

    return (def.$draw = function(d) {
      var $a, $b, self = this;

      (($a = [$scope.get('COLOR')]), $b = d, $b['$stroke_color='].apply($b, $a), $a[$a.length-1]);
      d.$push();
      d.$translate(self.position);
      d.$rotate(self.direction['$+']((($scope.get('Math'))._scope.get('PI'))['$/'](2)));
      d.$translate(self.size['$-@']()['$/'](2));
      d.$begin_shape();
      d.$move_to($scope.get('V')['$[]'](self.size.$x()['$/'](2), 0));
      d.$line_to($scope.get('V')['$[]'](self.size.$x(), self.size.$y()));
      d.$line_to($scope.get('V')['$[]'](self.size.$x()['$/'](2), self.size.$y()['$/'](2)));
      d.$line_to($scope.get('V')['$[]'](0, self.size.$y()));
      d.$line_to($scope.get('V')['$[]'](self.size.$x()['$/'](2), 0));
      d.$end_shape();
      d.$stroke_shape();
      if ((($a = self.thrusting) !== nil && (!$a._isBoolean || $a == true))) {
        d.$begin_shape();
        d.$move_to($scope.get('V')['$[]'](self.size.$x()['$/'](2), self.size.$y()['$/'](2)));
        d.$line_to($scope.get('V')['$[]'](self.size.$x()['$/'](2), self.size.$y()));
        d.$end_shape();
        d.$stroke_shape();};
      return d.$pop();
    }, nil) && 'draw';
  })(self, $scope.get('Thing'))
};

/* Generated by Opal 0.7.0.dev */
Opal.modules["game"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass, $hash2 = $opal.hash2;

  $opal.add_stubs(['$[]', '$attr_accessor', '$[]=', '$config', '$<<', '$new', '$/', '$size', '$display', '$times', '$*', '$rand', '$width', '$height', '$stroke_color=', '$stroke_width=', '$fill_color=', '$pressing?', '$keyboard', '$pressed?', '$clear', '$each', '$nil?', '$update', '$draw', '$draw_help', '$private', '$font_size=', '$fill_text']);
  return (function($base, $super) {
    function $AsteroidsGame(){};
    var self = $AsteroidsGame = $klass($base, $super, 'AsteroidsGame', $AsteroidsGame);

    var def = self._proto, $scope = self._scope;

    def.things = def.input = nil;
    $opal.cdecl($scope, 'BG_COLOR', $scope.get('C')['$[]']("#001133"));

    self.$attr_accessor("input", "things");

    self.$config()['$[]']("display")['$[]=']("size", $scope.get('V')['$[]'](720, 720));

    def.$setup = function() {
      var $a, $b, TMP_1, $c, self = this;

      self.things = [];
      self.things['$<<']($scope.get('Ship').$new($hash2(["position"], {"position": self.$display().$size()['$/'](2)})));
      ($a = ($b = (6)).$times, $a._p = (TMP_1 = function(){var self = TMP_1._s || this;
        if (self.things == null) self.things = nil;

      return self.things['$<<']($scope.get('Asteroid').$new($hash2(["position", "side_count"], {"position": $scope.get('V')['$[]']($scope.get('Math').$rand()['$*'](self.$display().$width()), $scope.get('Math').$rand()['$*'](self.$display().$height())), "side_count": 6})))}, TMP_1._s = self, TMP_1), $a).call($b);
      self.input = $hash2([], {});
      self.shot = false;
      (($a = [$scope.get('C')['$[]']("#dddddd")]), $c = self.$display(), $c['$stroke_color='].apply($c, $a), $a[$a.length-1]);
      (($a = [4]), $c = self.$display(), $c['$stroke_width='].apply($c, $a), $a[$a.length-1]);
      return (($a = [$scope.get('BG_COLOR')]), $c = self.$display(), $c['$fill_color='].apply($c, $a), $a[$a.length-1]);
    };

    def.$update = function(elapsed) {
      var $a, $b, TMP_2, self = this;

      self.input['$[]=']("left", self.$keyboard()['$pressing?']("left"));
      self.input['$[]=']("right", self.$keyboard()['$pressing?']("right"));
      self.input['$[]=']("up", self.$keyboard()['$pressing?']("up"));
      self.input['$[]=']("shoot", self.$keyboard()['$pressed?']("z"));
      (($a = [$scope.get('BG_COLOR')]), $b = self.$display(), $b['$fill_color='].apply($b, $a), $a[$a.length-1]);
      self.$display().$clear();
      ($a = ($b = self.things).$each, $a._p = (TMP_2 = function(t){var self = TMP_2._s || this, $a;
if (t == null) t = nil;
      if ((($a = t['$nil?']()) !== nil && (!$a._isBoolean || $a == true))) {
          return nil;};
        t.$update(elapsed, self);
        return t.$draw(self.$display());}, TMP_2._s = self, TMP_2), $a).call($b);
      return self.$draw_help(self.$display());
    };

    self.$private();

    return (def.$draw_help = function(d) {
      var $a, $b, self = this;

      (($a = [16]), $b = d, $b['$font_size='].apply($b, $a), $a[$a.length-1]);
      (($a = [$scope.get('C')['$[]']("#999999")]), $b = d, $b['$fill_color='].apply($b, $a), $a[$a.length-1]);
      d.$fill_text("Left/Right - Turn", $scope.get('V')['$[]'](500, 100));
      d.$fill_text("Up - Thrust", $scope.get('V')['$[]'](500, 120));
      return d.$fill_text("z - Shoot", $scope.get('V')['$[]'](500, 140));
    }, nil) && 'draw_help';
  })(self, $scope.get('Game'))
};

/* Generated by Opal 0.7.0.dev */
(function($opal) {
  $opal.dynamic_require_severity = "error";
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice;

  $opal.add_stubs(['$require']);
  self.$require("math");
  self.$require("thing");
  self.$require("asteroid");
  self.$require("bullet");
  self.$require("ship");
  return self.$require("game");
})(Opal);

//# sourceMappingURL=code.map
;
